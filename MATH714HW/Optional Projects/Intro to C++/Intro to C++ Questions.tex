\documentclass{article}
\usepackage{amsmath}
\usepackage{tcolorbox}
\usepackage[margin=0.5in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts, fancyhdr, color, comment, graphicx, environ}
\usepackage{float}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage[shortlabels]{enumitem}
\usepackage{indentfirst}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage{extarrows}
\graphicspath{./}
\makeatletter
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother

% Define a new environment for problems
\newcounter{problemCounter}
\newtcolorbox{problem}[2][]{colback=white, colframe=black, boxrule=0.5mm, arc=4mm, auto outer arc, title={\ifstrempty{#1}{Problem \stepcounter{problemCounter}\theproblemCounter}{#1}}}

% \renewcommand{\labelenumi}{\alph{enumi})}
\def\zz{{\mathbb Z}}
\def\rr{{\mathbb R}}
\def\qq{{\mathbb Q}}
\def\cc{{\mathbb C}}
\def\nn{{\mathbb N}}
\def\ss{{\mathbb S}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtcolorbox{proposition}[1][]{colback=white, colframe=blue, boxrule=0.5mm, arc=4mm, auto outer arc, title={Proposition #1}}
\newtcolorbox{definition}[1][]{colback=white, colframe=violet, boxrule=0.5mm, arc=4mm, auto outer arc, title={Definition #1}}
\newcommand{\Zmod}[1]{\zz/#1\zz}
\newcommand{\partFrac}[2]{\frac{\partial #1}{\partial #2}}

\newcommand\Mydiv[2]{%
$\strut#1$\kern.25em\smash{\raise.3ex\hbox{$\big)$}}$\mkern-8mu
        \overline{\enspace\strut#2}$}

\begin{document}

\begin{center}
    Math 714
    \hfill Optional Project: Introduction to C++ Questions 
    \hfill \textit{Stephen Cornelius}
\end{center}
\textbf{Note(s):} Use of Generative AI was used for styling images in the \LaTeX $\,$document. I was unsure of what was wanted as answers to the questions so if the following is not what was intended please let me know and I will redo the assignment.
\begin{problem} \\ 
\begin{enumerate}[a)]
    \item Write a program that can evaluate the numbers $c_{n,k}$ in Pascal's triangle using a recurrence relation.
Define $c_{n,0} = 1$ for all $n \geq 0$ and $c_{0,k}=0$ for $k \geq 0$. Then the entries for $n + 1$ and be computed from the entries for $n$ using 
\[
		c_{n+1,k} = c_{n,k} + c_{n,k-1}.
	\]
	Print a table of entries in Pascal's triangle for $0 \leq n \leq 7$ and $0 \leq k \leq 7$. You should find that $c_{n,k} = 0$ for $k > n$, and those terms can be left blank in your table.


	\item Extend your program so that it prints ASCII art, displaying a "." character for each even number and a "\#" character for each odd number. Hence the first few lines would be
	\begin{verbatim}
        #
        ##
        #.#
        ####
    \end{verbatim}
	Using your program, extend this output to $n = 31$.
\end{enumerate}
\end{problem}
\begin{enumerate}[a)]
    \item Originally, I implemented the recurrence relation in a function (\verb|PascalTriangle_Coefficients(int n, int k)|) that called itself. I then called this function in \verb|main()|. While this worked, I realized that it was calculating the same values over and over again which made it very slow. Instead wrote a function (\verb|Generate_Pascal_Triangle(int numRows)|) that output a vector of vectors that stored the values as they were calculated. This made it much faster. I also added a function to print the triangle in a nice format. Below is the output of the program when I input 7 rows. \\ 
    \begin{center}
        \includegraphics[width=0.5\textwidth]{OpHw1_1a.png}
    \end{center}
    \newpage
    \item I was tasked with outputting a table of for Pascal's triangle where each even number was replaced by a "." and each odd number was replaced by a "\#". I modified my previous program to do this. The output reminded me of the Serpinski triangle. Below is the output of the program when I input 31 rows. \\
    \begin{center}
        \includegraphics[width=0.5\textwidth]{OpHw1_1b.png}
    \end{center}
\end{enumerate}


\begin{problem} \\ 
    \begin{enumerate}[a)]
        \item Write a function that takes in two arrays and preforms matrix multiplication. \\
    Your function's signature should be:
    \begin{verbatim}
        void mat_mul(const double* A, const double* B, double* C, int m, int n, int p);
    \end{verbatim}
    The function should compute $C = AB$, where $A \in \rr^{m\times n}, B \in \rr^{n \times p}$, and $C \in \rr^{m \times p}$. Test your program on the matrices
    \[
        A = \begin{pmatrix}
            0 & 1 & 2 \\
            0 & 1 & 2 
        \end{pmatrix},
        \quad 
        B = \begin{pmatrix}
            0 & 1 & 2 & 3 \\
            0 & 1 & 2 & 3 \\
            0 & 1 & 2 & 3 
        \end{pmatrix},
    \]
    which can be generated using the provided \verb|gradient_matrix| function.
    \item \textbf{Optional.} Measure the time $T(m)$ to generate two random matrices $A, B \in \rr^{m\times m}$ and multiply them together using your routine. Calculate $T(m)$ for $m = 100, 200, 300, \dots , 1600$. Use linear regression on fit the data to 
    \[
        T(m) = Cm^\alpha
    \] 
    for constants $C$ and $\alpha$, comment on whether the value $\alpha$ is consistent with your matrix multiplication algorithm.
    \end{enumerate}
\end{problem}

\begin{enumerate}[a)]
    \item I created the function \verb|mat_mul| that takes in two matrices and performs matrix multiplication. I also created a function \verb|print_matrix| to print the resulting matrix in a nice format. Below is the output of the program when I input the matrices given in the problem statement. \\
    \begin{center}
        \includegraphics[width=0.5\textwidth]{OpHw1_2a.png}
    \end{center}
    \item I did not do the optional part of this problem as I ran out of time.
\end{enumerate}


\begin{problem} \\ 
    Consider Conway's Game of Life on a regular periodic $m \times n$ grid, with cells indexed as $(i,j)$ where $i \in \{ 0, 1, \dots, m-1 \}$ and $j \in \{ 0, 1, \dots, n-1 \}$. Each cell can either be alive or dead. Each cell has eight neighbors (the cells directly adjacent to it, including diagonals) --- This is also known as the 9-cell (Moore) neighborhood. Define $N_{i,j}$ to be the number alive neighbors of $(i,j)$. Hence $0 \leq N_{i,j} \leq 8$. \\
    In one generation, all cells are simultaneously updated according to the following rules:
    \begin{itemize}
        \item An alive cell at $(i,j)$ remains alive if $N_{i,j} \in \{ 2, 3 \}$, and dies otherwise.
        \item A dead cell at $(i,j)$ becomes alive if $N_{i,j} = 3$.
        \item All other cells remain unchanged.
    \end{itemize}

    \begin{enumerate}[a)]
        \item Implement this automaton on a grid of size $(m,n) = (80,40)$. Initialize the grid as empty except for the following configuration, where gray indicates alive cells:
        \begin{center}
            \includegraphics[width=0.5\textwidth]{OpHw1_3aQ.png}
        \end{center}
        Since periodic boundary conditions are used, the exact placement of the pattern in the grid is not important. \\
        Print a snapshow of the intitial condition, using ASCII art or another method of your choice. Run the system for 200 generations, and rpint snapshots after 1, 2, 4, 50, 100, and 200 generations.
        \item \textbf{Optional.} Experiment with other known patterns in the Game of Life. Or create your own patterns!
    \end{enumerate}
\end{problem}

\begin{enumerate}[a)]
    \item I implemented the Game of Life automaton on a grid of size $(m,n) = (80,40)$. The initial configuration was set up as specified in the problem statement. Below is a snapshot of the initial condition:
    \begin{center}
        \includegraphics[width=0.25\textwidth]{OpHw1_3aInit.png}
    \end{center}
    I ran the system for 200 generations and printed snapshots after 1, 2, 4, 50, 100, and 200 generations. Below are the snapshots at the specified generations:
    \begin{center}
        \includegraphics[width=0.25\textwidth]{OpHw1_3a1.png}    
        \includegraphics[width=0.25\textwidth]{OpHw1_3a2.png} \\
        Generation 1 \hspace{3cm} Generation 2
    \end{center}
    \begin{center}
        \includegraphics[width=0.25\textwidth]{OpHw1_3a4.png}
        \includegraphics[width=0.25\textwidth]{OpHw1_3a50.png} \\
        Generation 4 \hspace{3cm} Generation 50
    \end{center}
    \begin{center}
        \includegraphics[width=0.25\textwidth]{OpHw1_3a100.png}
        \includegraphics[width=0.25\textwidth]{OpHw1_3a200.png} \\
        Generation 100 \hspace{3cm} Generation 200
    \end{center}
\end{enumerate}







\end{document}